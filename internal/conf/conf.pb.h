// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: conf.proto
// Protobuf C++ Version: 5.26.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_conf_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_conf_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION != 5026001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "google/protobuf/duration.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_conf_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_conf_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_conf_2eproto;
namespace kratos {
namespace api {
class Bootstrap;
struct BootstrapDefaultTypeInternal;
extern BootstrapDefaultTypeInternal _Bootstrap_default_instance_;
class Data;
struct DataDefaultTypeInternal;
extern DataDefaultTypeInternal _Data_default_instance_;
class Data_Database;
struct Data_DatabaseDefaultTypeInternal;
extern Data_DatabaseDefaultTypeInternal _Data_Database_default_instance_;
class Data_Redis;
struct Data_RedisDefaultTypeInternal;
extern Data_RedisDefaultTypeInternal _Data_Redis_default_instance_;
class Server;
struct ServerDefaultTypeInternal;
extern ServerDefaultTypeInternal _Server_default_instance_;
class Server_GRPC;
struct Server_GRPCDefaultTypeInternal;
extern Server_GRPCDefaultTypeInternal _Server_GRPC_default_instance_;
class Server_HTTP;
struct Server_HTTPDefaultTypeInternal;
extern Server_HTTPDefaultTypeInternal _Server_HTTP_default_instance_;
}  // namespace api
}  // namespace kratos
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace kratos {
namespace api {

// ===================================================================


// -------------------------------------------------------------------

class Data_Database final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Data.Database) */ {
 public:
  inline Data_Database() : Data_Database(nullptr) {}
  ~Data_Database() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Data_Database(
      ::google::protobuf::internal::ConstantInitialized);

  inline Data_Database(const Data_Database& from) : Data_Database(nullptr, from) {}
  inline Data_Database(Data_Database&& from) noexcept
      : Data_Database(nullptr, std::move(from)) {}
  inline Data_Database& operator=(const Data_Database& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data_Database& operator=(Data_Database&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data_Database& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data_Database* internal_default_instance() {
    return reinterpret_cast<const Data_Database*>(
        &_Data_Database_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(Data_Database& a, Data_Database& b) { a.Swap(&b); }
  inline void Swap(Data_Database* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data_Database* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data_Database* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Data_Database>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data_Database& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Data_Database& from) { Data_Database::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Data_Database* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Data.Database"; }

 protected:
  explicit Data_Database(::google::protobuf::Arena* arena);
  Data_Database(::google::protobuf::Arena* arena, const Data_Database& from);
  Data_Database(::google::protobuf::Arena* arena, Data_Database&& from) noexcept
      : Data_Database(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDriverFieldNumber = 1,
    kSourceFieldNumber = 2,
  };
  // string driver = 1;
  void clear_driver() ;
  const std::string& driver() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_driver(Arg_&& arg, Args_... args);
  std::string* mutable_driver();
  PROTOBUF_NODISCARD std::string* release_driver();
  void set_allocated_driver(std::string* value);

  private:
  const std::string& _internal_driver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_driver(
      const std::string& value);
  std::string* _internal_mutable_driver();

  public:
  // string source = 2;
  void clear_source() ;
  const std::string& source() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_source(Arg_&& arg, Args_... args);
  std::string* mutable_source();
  PROTOBUF_NODISCARD std::string* release_source();
  void set_allocated_source(std::string* value);

  private:
  const std::string& _internal_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source(
      const std::string& value);
  std::string* _internal_mutable_source();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Data.Database)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      45, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr driver_;
    ::google::protobuf::internal::ArenaStringPtr source_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_HTTP final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Server.HTTP) */ {
 public:
  inline Server_HTTP() : Server_HTTP(nullptr) {}
  ~Server_HTTP() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Server_HTTP(
      ::google::protobuf::internal::ConstantInitialized);

  inline Server_HTTP(const Server_HTTP& from) : Server_HTTP(nullptr, from) {}
  inline Server_HTTP(Server_HTTP&& from) noexcept
      : Server_HTTP(nullptr, std::move(from)) {}
  inline Server_HTTP& operator=(const Server_HTTP& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_HTTP& operator=(Server_HTTP&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_HTTP& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_HTTP* internal_default_instance() {
    return reinterpret_cast<const Server_HTTP*>(
        &_Server_HTTP_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Server_HTTP& a, Server_HTTP& b) { a.Swap(&b); }
  inline void Swap(Server_HTTP* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_HTTP* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_HTTP* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Server_HTTP>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Server_HTTP& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Server_HTTP& from) { Server_HTTP::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Server_HTTP* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Server.HTTP"; }

 protected:
  explicit Server_HTTP(::google::protobuf::Arena* arena);
  Server_HTTP(::google::protobuf::Arena* arena, const Server_HTTP& from);
  Server_HTTP(::google::protobuf::Arena* arena, Server_HTTP&& from) noexcept
      : Server_HTTP(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1;
  void clear_network() ;
  const std::string& network() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network(Arg_&& arg, Args_... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* value);

  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(
      const std::string& value);
  std::string* _internal_mutable_network();

  public:
  // string addr = 2;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // .google.protobuf.Duration timeout = 3;
  bool has_timeout() const;
  void clear_timeout() ;
  const ::google::protobuf::Duration& timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_timeout();
  ::google::protobuf::Duration* mutable_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_timeout();

  private:
  const ::google::protobuf::Duration& _internal_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_timeout();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Server.HTTP)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr network_;
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::Duration* timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server_GRPC final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Server.GRPC) */ {
 public:
  inline Server_GRPC() : Server_GRPC(nullptr) {}
  ~Server_GRPC() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Server_GRPC(
      ::google::protobuf::internal::ConstantInitialized);

  inline Server_GRPC(const Server_GRPC& from) : Server_GRPC(nullptr, from) {}
  inline Server_GRPC(Server_GRPC&& from) noexcept
      : Server_GRPC(nullptr, std::move(from)) {}
  inline Server_GRPC& operator=(const Server_GRPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server_GRPC& operator=(Server_GRPC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server_GRPC& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server_GRPC* internal_default_instance() {
    return reinterpret_cast<const Server_GRPC*>(
        &_Server_GRPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Server_GRPC& a, Server_GRPC& b) { a.Swap(&b); }
  inline void Swap(Server_GRPC* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server_GRPC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server_GRPC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Server_GRPC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Server_GRPC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Server_GRPC& from) { Server_GRPC::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Server_GRPC* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Server.GRPC"; }

 protected:
  explicit Server_GRPC(::google::protobuf::Arena* arena);
  Server_GRPC(::google::protobuf::Arena* arena, const Server_GRPC& from);
  Server_GRPC(::google::protobuf::Arena* arena, Server_GRPC&& from) noexcept
      : Server_GRPC(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kTimeoutFieldNumber = 3,
  };
  // string network = 1;
  void clear_network() ;
  const std::string& network() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network(Arg_&& arg, Args_... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* value);

  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(
      const std::string& value);
  std::string* _internal_mutable_network();

  public:
  // string addr = 2;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // .google.protobuf.Duration timeout = 3;
  bool has_timeout() const;
  void clear_timeout() ;
  const ::google::protobuf::Duration& timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_timeout();
  ::google::protobuf::Duration* mutable_timeout();
  void set_allocated_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_timeout();

  private:
  const ::google::protobuf::Duration& _internal_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_timeout();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Server.GRPC)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr network_;
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::Duration* timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Data_Redis final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Data.Redis) */ {
 public:
  inline Data_Redis() : Data_Redis(nullptr) {}
  ~Data_Redis() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Data_Redis(
      ::google::protobuf::internal::ConstantInitialized);

  inline Data_Redis(const Data_Redis& from) : Data_Redis(nullptr, from) {}
  inline Data_Redis(Data_Redis&& from) noexcept
      : Data_Redis(nullptr, std::move(from)) {}
  inline Data_Redis& operator=(const Data_Redis& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data_Redis& operator=(Data_Redis&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data_Redis& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data_Redis* internal_default_instance() {
    return reinterpret_cast<const Data_Redis*>(
        &_Data_Redis_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(Data_Redis& a, Data_Redis& b) { a.Swap(&b); }
  inline void Swap(Data_Redis* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data_Redis* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data_Redis* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Data_Redis>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data_Redis& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Data_Redis& from) { Data_Redis::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Data_Redis* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Data.Redis"; }

 protected:
  explicit Data_Redis(::google::protobuf::Arena* arena);
  Data_Redis(::google::protobuf::Arena* arena, const Data_Redis& from);
  Data_Redis(::google::protobuf::Arena* arena, Data_Redis&& from) noexcept
      : Data_Redis(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNetworkFieldNumber = 1,
    kAddrFieldNumber = 2,
    kReadTimeoutFieldNumber = 3,
    kWriteTimeoutFieldNumber = 4,
  };
  // string network = 1;
  void clear_network() ;
  const std::string& network() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network(Arg_&& arg, Args_... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* value);

  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(
      const std::string& value);
  std::string* _internal_mutable_network();

  public:
  // string addr = 2;
  void clear_addr() ;
  const std::string& addr() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_addr(Arg_&& arg, Args_... args);
  std::string* mutable_addr();
  PROTOBUF_NODISCARD std::string* release_addr();
  void set_allocated_addr(std::string* value);

  private:
  const std::string& _internal_addr() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_addr(
      const std::string& value);
  std::string* _internal_mutable_addr();

  public:
  // .google.protobuf.Duration read_timeout = 3;
  bool has_read_timeout() const;
  void clear_read_timeout() ;
  const ::google::protobuf::Duration& read_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_read_timeout();
  ::google::protobuf::Duration* mutable_read_timeout();
  void set_allocated_read_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_read_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_read_timeout();

  private:
  const ::google::protobuf::Duration& _internal_read_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_read_timeout();

  public:
  // .google.protobuf.Duration write_timeout = 4;
  bool has_write_timeout() const;
  void clear_write_timeout() ;
  const ::google::protobuf::Duration& write_timeout() const;
  PROTOBUF_NODISCARD ::google::protobuf::Duration* release_write_timeout();
  ::google::protobuf::Duration* mutable_write_timeout();
  void set_allocated_write_timeout(::google::protobuf::Duration* value);
  void unsafe_arena_set_allocated_write_timeout(::google::protobuf::Duration* value);
  ::google::protobuf::Duration* unsafe_arena_release_write_timeout();

  private:
  const ::google::protobuf::Duration& _internal_write_timeout() const;
  ::google::protobuf::Duration* _internal_mutable_write_timeout();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Data.Redis)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      41, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr network_;
    ::google::protobuf::internal::ArenaStringPtr addr_;
    ::google::protobuf::Duration* read_timeout_;
    ::google::protobuf::Duration* write_timeout_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Server final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Server) */ {
 public:
  inline Server() : Server(nullptr) {}
  ~Server() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Server(
      ::google::protobuf::internal::ConstantInitialized);

  inline Server(const Server& from) : Server(nullptr, from) {}
  inline Server(Server&& from) noexcept
      : Server(nullptr, std::move(from)) {}
  inline Server& operator=(const Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline Server& operator=(Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const Server* internal_default_instance() {
    return reinterpret_cast<const Server*>(
        &_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(Server& a, Server& b) { a.Swap(&b); }
  inline void Swap(Server* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Server* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Server* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Server>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Server& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Server& from) { Server::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Server* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Server"; }

 protected:
  explicit Server(::google::protobuf::Arena* arena);
  Server(::google::protobuf::Arena* arena, const Server& from);
  Server(::google::protobuf::Arena* arena, Server&& from) noexcept
      : Server(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using HTTP = Server_HTTP;
  using GRPC = Server_GRPC;

  // accessors -------------------------------------------------------
  enum : int {
    kHttpFieldNumber = 1,
    kGrpcFieldNumber = 2,
  };
  // .kratos.api.Server.HTTP http = 1;
  bool has_http() const;
  void clear_http() ;
  const ::kratos::api::Server_HTTP& http() const;
  PROTOBUF_NODISCARD ::kratos::api::Server_HTTP* release_http();
  ::kratos::api::Server_HTTP* mutable_http();
  void set_allocated_http(::kratos::api::Server_HTTP* value);
  void unsafe_arena_set_allocated_http(::kratos::api::Server_HTTP* value);
  ::kratos::api::Server_HTTP* unsafe_arena_release_http();

  private:
  const ::kratos::api::Server_HTTP& _internal_http() const;
  ::kratos::api::Server_HTTP* _internal_mutable_http();

  public:
  // .kratos.api.Server.GRPC grpc = 2;
  bool has_grpc() const;
  void clear_grpc() ;
  const ::kratos::api::Server_GRPC& grpc() const;
  PROTOBUF_NODISCARD ::kratos::api::Server_GRPC* release_grpc();
  ::kratos::api::Server_GRPC* mutable_grpc();
  void set_allocated_grpc(::kratos::api::Server_GRPC* value);
  void unsafe_arena_set_allocated_grpc(::kratos::api::Server_GRPC* value);
  ::kratos::api::Server_GRPC* unsafe_arena_release_grpc();

  private:
  const ::kratos::api::Server_GRPC& _internal_grpc() const;
  ::kratos::api::Server_GRPC* _internal_mutable_grpc();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Server)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::kratos::api::Server_HTTP* http_;
    ::kratos::api::Server_GRPC* grpc_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Data final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Data) */ {
 public:
  inline Data() : Data(nullptr) {}
  ~Data() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Data(
      ::google::protobuf::internal::ConstantInitialized);

  inline Data(const Data& from) : Data(nullptr, from) {}
  inline Data(Data&& from) noexcept
      : Data(nullptr, std::move(from)) {}
  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }
  inline Data& operator=(Data&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Data& default_instance() {
    return *internal_default_instance();
  }
  static inline const Data* internal_default_instance() {
    return reinterpret_cast<const Data*>(
        &_Data_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(Data& a, Data& b) { a.Swap(&b); }
  inline void Swap(Data* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Data* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Data* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Data>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Data& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Data& from) { Data::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Data* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Data"; }

 protected:
  explicit Data(::google::protobuf::Arena* arena);
  Data(::google::protobuf::Arena* arena, const Data& from);
  Data(::google::protobuf::Arena* arena, Data&& from) noexcept
      : Data(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------
  using Database = Data_Database;
  using Redis = Data_Redis;

  // accessors -------------------------------------------------------
  enum : int {
    kDatabaseFieldNumber = 1,
    kRedisFieldNumber = 2,
  };
  // .kratos.api.Data.Database database = 1;
  bool has_database() const;
  void clear_database() ;
  const ::kratos::api::Data_Database& database() const;
  PROTOBUF_NODISCARD ::kratos::api::Data_Database* release_database();
  ::kratos::api::Data_Database* mutable_database();
  void set_allocated_database(::kratos::api::Data_Database* value);
  void unsafe_arena_set_allocated_database(::kratos::api::Data_Database* value);
  ::kratos::api::Data_Database* unsafe_arena_release_database();

  private:
  const ::kratos::api::Data_Database& _internal_database() const;
  ::kratos::api::Data_Database* _internal_mutable_database();

  public:
  // .kratos.api.Data.Redis redis = 2;
  bool has_redis() const;
  void clear_redis() ;
  const ::kratos::api::Data_Redis& redis() const;
  PROTOBUF_NODISCARD ::kratos::api::Data_Redis* release_redis();
  ::kratos::api::Data_Redis* mutable_redis();
  void set_allocated_redis(::kratos::api::Data_Redis* value);
  void unsafe_arena_set_allocated_redis(::kratos::api::Data_Redis* value);
  ::kratos::api::Data_Redis* unsafe_arena_release_redis();

  private:
  const ::kratos::api::Data_Redis& _internal_redis() const;
  ::kratos::api::Data_Redis* _internal_mutable_redis();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Data)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::kratos::api::Data_Database* database_;
    ::kratos::api::Data_Redis* redis_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};
// -------------------------------------------------------------------

class Bootstrap final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:kratos.api.Bootstrap) */ {
 public:
  inline Bootstrap() : Bootstrap(nullptr) {}
  ~Bootstrap() override;
  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Bootstrap(
      ::google::protobuf::internal::ConstantInitialized);

  inline Bootstrap(const Bootstrap& from) : Bootstrap(nullptr, from) {}
  inline Bootstrap(Bootstrap&& from) noexcept
      : Bootstrap(nullptr, std::move(from)) {}
  inline Bootstrap& operator=(const Bootstrap& from) {
    CopyFrom(from);
    return *this;
  }
  inline Bootstrap& operator=(Bootstrap&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Bootstrap& default_instance() {
    return *internal_default_instance();
  }
  static inline const Bootstrap* internal_default_instance() {
    return reinterpret_cast<const Bootstrap*>(
        &_Bootstrap_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Bootstrap& a, Bootstrap& b) { a.Swap(&b); }
  inline void Swap(Bootstrap* other) {
    if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr && GetArena() == other->GetArena()) {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Bootstrap* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Bootstrap* New(::google::protobuf::Arena* arena = nullptr) const final {
    return ::google::protobuf::Message::DefaultConstruct<Bootstrap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Bootstrap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Bootstrap& from) { Bootstrap::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Bootstrap* other);
 private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() { return "kratos.api.Bootstrap"; }

 protected:
  explicit Bootstrap(::google::protobuf::Arena* arena);
  Bootstrap(::google::protobuf::Arena* arena, const Bootstrap& from);
  Bootstrap(::google::protobuf::Arena* arena, Bootstrap&& from) noexcept
      : Bootstrap(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::MessageLite::ClassData* GetClassData()
      const final;

 public:
  ::google::protobuf::Metadata GetMetadata() const final;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kServerFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // .kratos.api.Server server = 1;
  bool has_server() const;
  void clear_server() ;
  const ::kratos::api::Server& server() const;
  PROTOBUF_NODISCARD ::kratos::api::Server* release_server();
  ::kratos::api::Server* mutable_server();
  void set_allocated_server(::kratos::api::Server* value);
  void unsafe_arena_set_allocated_server(::kratos::api::Server* value);
  ::kratos::api::Server* unsafe_arena_release_server();

  private:
  const ::kratos::api::Server& _internal_server() const;
  ::kratos::api::Server* _internal_mutable_server();

  public:
  // .kratos.api.Data data = 2;
  bool has_data() const;
  void clear_data() ;
  const ::kratos::api::Data& data() const;
  PROTOBUF_NODISCARD ::kratos::api::Data* release_data();
  ::kratos::api::Data* mutable_data();
  void set_allocated_data(::kratos::api::Data* value);
  void unsafe_arena_set_allocated_data(::kratos::api::Data* value);
  ::kratos::api::Data* unsafe_arena_release_data();

  private:
  const ::kratos::api::Data& _internal_data() const;
  ::kratos::api::Data* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:kratos.api.Bootstrap)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::kratos::api::Server* server_;
    ::kratos::api::Data* data_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_conf_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Bootstrap

// .kratos.api.Server server = 1;
inline bool Bootstrap::has_server() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.server_ != nullptr);
  return value;
}
inline void Bootstrap::clear_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.server_ != nullptr) _impl_.server_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kratos::api::Server& Bootstrap::_internal_server() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Server* p = _impl_.server_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Server&>(::kratos::api::_Server_default_instance_);
}
inline const ::kratos::api::Server& Bootstrap::server() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Bootstrap.server)
  return _internal_server();
}
inline void Bootstrap::unsafe_arena_set_allocated_server(::kratos::api::Server* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.server_);
  }
  _impl_.server_ = reinterpret_cast<::kratos::api::Server*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Bootstrap.server)
}
inline ::kratos::api::Server* Bootstrap::release_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Server* released = _impl_.server_;
  _impl_.server_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Server* Bootstrap::unsafe_arena_release_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Bootstrap.server)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Server* temp = _impl_.server_;
  _impl_.server_ = nullptr;
  return temp;
}
inline ::kratos::api::Server* Bootstrap::_internal_mutable_server() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.server_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Server>(GetArena());
    _impl_.server_ = reinterpret_cast<::kratos::api::Server*>(p);
  }
  return _impl_.server_;
}
inline ::kratos::api::Server* Bootstrap::mutable_server() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kratos::api::Server* _msg = _internal_mutable_server();
  // @@protoc_insertion_point(field_mutable:kratos.api.Bootstrap.server)
  return _msg;
}
inline void Bootstrap::set_allocated_server(::kratos::api::Server* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.server_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.server_ = reinterpret_cast<::kratos::api::Server*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Bootstrap.server)
}

// .kratos.api.Data data = 2;
inline bool Bootstrap::has_data() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.data_ != nullptr);
  return value;
}
inline void Bootstrap::clear_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.data_ != nullptr) _impl_.data_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kratos::api::Data& Bootstrap::_internal_data() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Data* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Data&>(::kratos::api::_Data_default_instance_);
}
inline const ::kratos::api::Data& Bootstrap::data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Bootstrap.data)
  return _internal_data();
}
inline void Bootstrap::unsafe_arena_set_allocated_data(::kratos::api::Data* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = reinterpret_cast<::kratos::api::Data*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Bootstrap.data)
}
inline ::kratos::api::Data* Bootstrap::release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Data* released = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Data* Bootstrap::unsafe_arena_release_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Bootstrap.data)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Data* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::kratos::api::Data* Bootstrap::_internal_mutable_data() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.data_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Data>(GetArena());
    _impl_.data_ = reinterpret_cast<::kratos::api::Data*>(p);
  }
  return _impl_.data_;
}
inline ::kratos::api::Data* Bootstrap::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kratos::api::Data* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:kratos.api.Bootstrap.data)
  return _msg;
}
inline void Bootstrap::set_allocated_data(::kratos::api::Data* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.data_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.data_ = reinterpret_cast<::kratos::api::Data*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Bootstrap.data)
}

// -------------------------------------------------------------------

// Server_HTTP

// string network = 1;
inline void Server_HTTP::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.ClearToEmpty();
}
inline const std::string& Server_HTTP::network() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.HTTP.network)
  return _internal_network();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Server_HTTP::set_network(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Server.HTTP.network)
}
inline std::string* Server_HTTP::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.HTTP.network)
  return _s;
}
inline const std::string& Server_HTTP::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.network_.Get();
}
inline void Server_HTTP::_internal_set_network(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(value, GetArena());
}
inline std::string* Server_HTTP::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.network_.Mutable( GetArena());
}
inline std::string* Server_HTTP::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.HTTP.network)
  return _impl_.network_.Release();
}
inline void Server_HTTP::set_allocated_network(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.network_.IsDefault()) {
          _impl_.network_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.HTTP.network)
}

// string addr = 2;
inline void Server_HTTP::clear_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Server_HTTP::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.HTTP.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Server_HTTP::set_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Server.HTTP.addr)
}
inline std::string* Server_HTTP::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.HTTP.addr)
  return _s;
}
inline const std::string& Server_HTTP::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_.Get();
}
inline void Server_HTTP::_internal_set_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* Server_HTTP::_internal_mutable_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* Server_HTTP::release_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.HTTP.addr)
  return _impl_.addr_.Release();
}
inline void Server_HTTP::set_allocated_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.addr_.IsDefault()) {
          _impl_.addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.HTTP.addr)
}

// .google.protobuf.Duration timeout = 3;
inline bool Server_HTTP::has_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& Server_HTTP::_internal_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& Server_HTTP::timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.HTTP.timeout)
  return _internal_timeout();
}
inline void Server_HTTP::unsafe_arena_set_allocated_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Server.HTTP.timeout)
}
inline ::google::protobuf::Duration* Server_HTTP::release_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* Server_HTTP::unsafe_arena_release_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.HTTP.timeout)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* Server_HTTP::_internal_mutable_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.timeout_;
}
inline ::google::protobuf::Duration* Server_HTTP::mutable_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.HTTP.timeout)
  return _msg;
}
inline void Server_HTTP::set_allocated_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.HTTP.timeout)
}

// -------------------------------------------------------------------

// Server_GRPC

// string network = 1;
inline void Server_GRPC::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.ClearToEmpty();
}
inline const std::string& Server_GRPC::network() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.GRPC.network)
  return _internal_network();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Server_GRPC::set_network(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Server.GRPC.network)
}
inline std::string* Server_GRPC::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.GRPC.network)
  return _s;
}
inline const std::string& Server_GRPC::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.network_.Get();
}
inline void Server_GRPC::_internal_set_network(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(value, GetArena());
}
inline std::string* Server_GRPC::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.network_.Mutable( GetArena());
}
inline std::string* Server_GRPC::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.GRPC.network)
  return _impl_.network_.Release();
}
inline void Server_GRPC::set_allocated_network(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.network_.IsDefault()) {
          _impl_.network_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.GRPC.network)
}

// string addr = 2;
inline void Server_GRPC::clear_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Server_GRPC::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.GRPC.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Server_GRPC::set_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Server.GRPC.addr)
}
inline std::string* Server_GRPC::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.GRPC.addr)
  return _s;
}
inline const std::string& Server_GRPC::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_.Get();
}
inline void Server_GRPC::_internal_set_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* Server_GRPC::_internal_mutable_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* Server_GRPC::release_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.GRPC.addr)
  return _impl_.addr_.Release();
}
inline void Server_GRPC::set_allocated_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.addr_.IsDefault()) {
          _impl_.addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.GRPC.addr)
}

// .google.protobuf.Duration timeout = 3;
inline bool Server_GRPC::has_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& Server_GRPC::_internal_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& Server_GRPC::timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.GRPC.timeout)
  return _internal_timeout();
}
inline void Server_GRPC::unsafe_arena_set_allocated_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeout_);
  }
  _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Server.GRPC.timeout)
}
inline ::google::protobuf::Duration* Server_GRPC::release_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* Server_GRPC::unsafe_arena_release_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.GRPC.timeout)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.timeout_;
  _impl_.timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* Server_GRPC::_internal_mutable_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.timeout_;
}
inline ::google::protobuf::Duration* Server_GRPC::mutable_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_timeout();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.GRPC.timeout)
  return _msg;
}
inline void Server_GRPC::set_allocated_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.GRPC.timeout)
}

// -------------------------------------------------------------------

// Server

// .kratos.api.Server.HTTP http = 1;
inline bool Server::has_http() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.http_ != nullptr);
  return value;
}
inline void Server::clear_http() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.http_ != nullptr) _impl_.http_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kratos::api::Server_HTTP& Server::_internal_http() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Server_HTTP* p = _impl_.http_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Server_HTTP&>(::kratos::api::_Server_HTTP_default_instance_);
}
inline const ::kratos::api::Server_HTTP& Server::http() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.http)
  return _internal_http();
}
inline void Server::unsafe_arena_set_allocated_http(::kratos::api::Server_HTTP* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.http_);
  }
  _impl_.http_ = reinterpret_cast<::kratos::api::Server_HTTP*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Server.http)
}
inline ::kratos::api::Server_HTTP* Server::release_http() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Server_HTTP* released = _impl_.http_;
  _impl_.http_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Server_HTTP* Server::unsafe_arena_release_http() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.http)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Server_HTTP* temp = _impl_.http_;
  _impl_.http_ = nullptr;
  return temp;
}
inline ::kratos::api::Server_HTTP* Server::_internal_mutable_http() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.http_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Server_HTTP>(GetArena());
    _impl_.http_ = reinterpret_cast<::kratos::api::Server_HTTP*>(p);
  }
  return _impl_.http_;
}
inline ::kratos::api::Server_HTTP* Server::mutable_http() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kratos::api::Server_HTTP* _msg = _internal_mutable_http();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.http)
  return _msg;
}
inline void Server::set_allocated_http(::kratos::api::Server_HTTP* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.http_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.http_ = reinterpret_cast<::kratos::api::Server_HTTP*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.http)
}

// .kratos.api.Server.GRPC grpc = 2;
inline bool Server::has_grpc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.grpc_ != nullptr);
  return value;
}
inline void Server::clear_grpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.grpc_ != nullptr) _impl_.grpc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kratos::api::Server_GRPC& Server::_internal_grpc() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Server_GRPC* p = _impl_.grpc_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Server_GRPC&>(::kratos::api::_Server_GRPC_default_instance_);
}
inline const ::kratos::api::Server_GRPC& Server::grpc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Server.grpc)
  return _internal_grpc();
}
inline void Server::unsafe_arena_set_allocated_grpc(::kratos::api::Server_GRPC* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.grpc_);
  }
  _impl_.grpc_ = reinterpret_cast<::kratos::api::Server_GRPC*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Server.grpc)
}
inline ::kratos::api::Server_GRPC* Server::release_grpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Server_GRPC* released = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Server_GRPC* Server::unsafe_arena_release_grpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Server.grpc)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Server_GRPC* temp = _impl_.grpc_;
  _impl_.grpc_ = nullptr;
  return temp;
}
inline ::kratos::api::Server_GRPC* Server::_internal_mutable_grpc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.grpc_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Server_GRPC>(GetArena());
    _impl_.grpc_ = reinterpret_cast<::kratos::api::Server_GRPC*>(p);
  }
  return _impl_.grpc_;
}
inline ::kratos::api::Server_GRPC* Server::mutable_grpc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kratos::api::Server_GRPC* _msg = _internal_mutable_grpc();
  // @@protoc_insertion_point(field_mutable:kratos.api.Server.grpc)
  return _msg;
}
inline void Server::set_allocated_grpc(::kratos::api::Server_GRPC* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.grpc_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.grpc_ = reinterpret_cast<::kratos::api::Server_GRPC*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Server.grpc)
}

// -------------------------------------------------------------------

// Data_Database

// string driver = 1;
inline void Data_Database::clear_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.ClearToEmpty();
}
inline const std::string& Data_Database::driver() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Database.driver)
  return _internal_driver();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data_Database::set_driver(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Data.Database.driver)
}
inline std::string* Data_Database::mutable_driver() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_driver();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Database.driver)
  return _s;
}
inline const std::string& Data_Database::_internal_driver() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.driver_.Get();
}
inline void Data_Database::_internal_set_driver(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.Set(value, GetArena());
}
inline std::string* Data_Database::_internal_mutable_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.driver_.Mutable( GetArena());
}
inline std::string* Data_Database::release_driver() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Database.driver)
  return _impl_.driver_.Release();
}
inline void Data_Database::set_allocated_driver(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.driver_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.driver_.IsDefault()) {
          _impl_.driver_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Database.driver)
}

// string source = 2;
inline void Data_Database::clear_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.ClearToEmpty();
}
inline const std::string& Data_Database::source() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Database.source)
  return _internal_source();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data_Database::set_source(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Data.Database.source)
}
inline std::string* Data_Database::mutable_source() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_source();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Database.source)
  return _s;
}
inline const std::string& Data_Database::_internal_source() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.source_.Get();
}
inline void Data_Database::_internal_set_source(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.Set(value, GetArena());
}
inline std::string* Data_Database::_internal_mutable_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.source_.Mutable( GetArena());
}
inline std::string* Data_Database::release_source() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Database.source)
  return _impl_.source_.Release();
}
inline void Data_Database::set_allocated_source(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.source_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.source_.IsDefault()) {
          _impl_.source_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Database.source)
}

// -------------------------------------------------------------------

// Data_Redis

// string network = 1;
inline void Data_Redis::clear_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.ClearToEmpty();
}
inline const std::string& Data_Redis::network() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Redis.network)
  return _internal_network();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data_Redis::set_network(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Data.Redis.network)
}
inline std::string* Data_Redis::mutable_network() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Redis.network)
  return _s;
}
inline const std::string& Data_Redis::_internal_network() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.network_.Get();
}
inline void Data_Redis::_internal_set_network(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.Set(value, GetArena());
}
inline std::string* Data_Redis::_internal_mutable_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.network_.Mutable( GetArena());
}
inline std::string* Data_Redis::release_network() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Redis.network)
  return _impl_.network_.Release();
}
inline void Data_Redis::set_allocated_network(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.network_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.network_.IsDefault()) {
          _impl_.network_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Redis.network)
}

// string addr = 2;
inline void Data_Redis::clear_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.ClearToEmpty();
}
inline const std::string& Data_Redis::addr() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Redis.addr)
  return _internal_addr();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Data_Redis::set_addr(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:kratos.api.Data.Redis.addr)
}
inline std::string* Data_Redis::mutable_addr() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_addr();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Redis.addr)
  return _s;
}
inline const std::string& Data_Redis::_internal_addr() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.addr_.Get();
}
inline void Data_Redis::_internal_set_addr(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.Set(value, GetArena());
}
inline std::string* Data_Redis::_internal_mutable_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _impl_.addr_.Mutable( GetArena());
}
inline std::string* Data_Redis::release_addr() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Redis.addr)
  return _impl_.addr_.Release();
}
inline void Data_Redis::set_allocated_addr(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.addr_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.addr_.IsDefault()) {
          _impl_.addr_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Redis.addr)
}

// .google.protobuf.Duration read_timeout = 3;
inline bool Data_Redis::has_read_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.read_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& Data_Redis::_internal_read_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.read_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& Data_Redis::read_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Redis.read_timeout)
  return _internal_read_timeout();
}
inline void Data_Redis::unsafe_arena_set_allocated_read_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_timeout_);
  }
  _impl_.read_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Data.Redis.read_timeout)
}
inline ::google::protobuf::Duration* Data_Redis::release_read_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* released = _impl_.read_timeout_;
  _impl_.read_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* Data_Redis::unsafe_arena_release_read_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Redis.read_timeout)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::google::protobuf::Duration* temp = _impl_.read_timeout_;
  _impl_.read_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* Data_Redis::_internal_mutable_read_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.read_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.read_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.read_timeout_;
}
inline ::google::protobuf::Duration* Data_Redis::mutable_read_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::google::protobuf::Duration* _msg = _internal_mutable_read_timeout();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Redis.read_timeout)
  return _msg;
}
inline void Data_Redis::set_allocated_read_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.read_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.read_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Redis.read_timeout)
}

// .google.protobuf.Duration write_timeout = 4;
inline bool Data_Redis::has_write_timeout() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.write_timeout_ != nullptr);
  return value;
}
inline const ::google::protobuf::Duration& Data_Redis::_internal_write_timeout() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::google::protobuf::Duration* p = _impl_.write_timeout_;
  return p != nullptr ? *p : reinterpret_cast<const ::google::protobuf::Duration&>(::google::protobuf::_Duration_default_instance_);
}
inline const ::google::protobuf::Duration& Data_Redis::write_timeout() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.Redis.write_timeout)
  return _internal_write_timeout();
}
inline void Data_Redis::unsafe_arena_set_allocated_write_timeout(::google::protobuf::Duration* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.write_timeout_);
  }
  _impl_.write_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Data.Redis.write_timeout)
}
inline ::google::protobuf::Duration* Data_Redis::release_write_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* released = _impl_.write_timeout_;
  _impl_.write_timeout_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::google::protobuf::Duration* Data_Redis::unsafe_arena_release_write_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.Redis.write_timeout)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::google::protobuf::Duration* temp = _impl_.write_timeout_;
  _impl_.write_timeout_ = nullptr;
  return temp;
}
inline ::google::protobuf::Duration* Data_Redis::_internal_mutable_write_timeout() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.write_timeout_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::google::protobuf::Duration>(GetArena());
    _impl_.write_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(p);
  }
  return _impl_.write_timeout_;
}
inline ::google::protobuf::Duration* Data_Redis::mutable_write_timeout() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::google::protobuf::Duration* _msg = _internal_mutable_write_timeout();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.Redis.write_timeout)
  return _msg;
}
inline void Data_Redis::set_allocated_write_timeout(::google::protobuf::Duration* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.write_timeout_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.write_timeout_ = reinterpret_cast<::google::protobuf::Duration*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.Redis.write_timeout)
}

// -------------------------------------------------------------------

// Data

// .kratos.api.Data.Database database = 1;
inline bool Data::has_database() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.database_ != nullptr);
  return value;
}
inline void Data::clear_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.database_ != nullptr) _impl_.database_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::kratos::api::Data_Database& Data::_internal_database() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Data_Database* p = _impl_.database_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Data_Database&>(::kratos::api::_Data_Database_default_instance_);
}
inline const ::kratos::api::Data_Database& Data::database() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.database)
  return _internal_database();
}
inline void Data::unsafe_arena_set_allocated_database(::kratos::api::Data_Database* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.database_);
  }
  _impl_.database_ = reinterpret_cast<::kratos::api::Data_Database*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Data.database)
}
inline ::kratos::api::Data_Database* Data::release_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Data_Database* released = _impl_.database_;
  _impl_.database_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Data_Database* Data::unsafe_arena_release_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.database)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::kratos::api::Data_Database* temp = _impl_.database_;
  _impl_.database_ = nullptr;
  return temp;
}
inline ::kratos::api::Data_Database* Data::_internal_mutable_database() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.database_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Data_Database>(GetArena());
    _impl_.database_ = reinterpret_cast<::kratos::api::Data_Database*>(p);
  }
  return _impl_.database_;
}
inline ::kratos::api::Data_Database* Data::mutable_database() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::kratos::api::Data_Database* _msg = _internal_mutable_database();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.database)
  return _msg;
}
inline void Data::set_allocated_database(::kratos::api::Data_Database* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.database_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.database_ = reinterpret_cast<::kratos::api::Data_Database*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.database)
}

// .kratos.api.Data.Redis redis = 2;
inline bool Data::has_redis() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.redis_ != nullptr);
  return value;
}
inline void Data::clear_redis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.redis_ != nullptr) _impl_.redis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::kratos::api::Data_Redis& Data::_internal_redis() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::kratos::api::Data_Redis* p = _impl_.redis_;
  return p != nullptr ? *p : reinterpret_cast<const ::kratos::api::Data_Redis&>(::kratos::api::_Data_Redis_default_instance_);
}
inline const ::kratos::api::Data_Redis& Data::redis() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:kratos.api.Data.redis)
  return _internal_redis();
}
inline void Data::unsafe_arena_set_allocated_redis(::kratos::api::Data_Redis* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.redis_);
  }
  _impl_.redis_ = reinterpret_cast<::kratos::api::Data_Redis*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:kratos.api.Data.redis)
}
inline ::kratos::api::Data_Redis* Data::release_redis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Data_Redis* released = _impl_.redis_;
  _impl_.redis_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::kratos::api::Data_Redis* Data::unsafe_arena_release_redis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:kratos.api.Data.redis)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::kratos::api::Data_Redis* temp = _impl_.redis_;
  _impl_.redis_ = nullptr;
  return temp;
}
inline ::kratos::api::Data_Redis* Data::_internal_mutable_redis() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.redis_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::kratos::api::Data_Redis>(GetArena());
    _impl_.redis_ = reinterpret_cast<::kratos::api::Data_Redis*>(p);
  }
  return _impl_.redis_;
}
inline ::kratos::api::Data_Redis* Data::mutable_redis() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::kratos::api::Data_Redis* _msg = _internal_mutable_redis();
  // @@protoc_insertion_point(field_mutable:kratos.api.Data.redis)
  return _msg;
}
inline void Data::set_allocated_redis(::kratos::api::Data_Redis* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete (_impl_.redis_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.redis_ = reinterpret_cast<::kratos::api::Data_Redis*>(value);
  // @@protoc_insertion_point(field_set_allocated:kratos.api.Data.redis)
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace api
}  // namespace kratos


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_conf_2eproto_2epb_2eh
